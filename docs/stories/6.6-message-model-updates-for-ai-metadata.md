# Story 6.6: Message Model Updates for AI Metadata

## Status
Draft

## Story
**As a** developer,
**I want** to store AI metadata on messages,
**so that** the UI can display categories, sentiment, and scores for messages.

## Acceptance Criteria
1. AI fields added to MessageEntity (all optional except `isAIGenerated`)
2. SwiftData migration handled automatically (optional fields)
3. RTDB sync includes AI metadata
4. RTDB observer updates messages when AI metadata arrives
5. Backward compatible with existing messages (nil values)
6. Cloud Function updates propagate to iOS automatically

## Tasks / Subtasks

- [ ] Verify required files exist (prerequisite)
  - [ ] Confirm `buzzbox/Core/Models/MessageEntity.swift` exists
  - [ ] Confirm `buzzbox/Core/Services/RealtimeDBService.swift` exists
  - [ ] If files don't exist at these paths, search for actual locations
  - [ ] Document actual file paths in Dev Notes section
  - [ ] Verify MessageEntity uses @Model macro from SwiftData

- [ ] Update MessageEntity model (AC: 1, 2)
  - [ ] Open `buzzbox/Core/Models/MessageEntity.swift`
  - [ ] Add optional AI metadata properties:
    - `var aiCategory: String?` // "fan" | "business" | "spam" | "urgent"
    - `var aiSentiment: String?` // "positive" | "negative" | "urgent" | "neutral"
    - `var aiOpportunityScore: Int?` // 0-100 (only for business)
    - `var isAIGenerated: Bool = false` // True if FAQ auto-response
    - `var aiProcessedAt: Date?` // When AI processing completed
  - [ ] Update initializer to include new AI metadata parameters (all optional with defaults)
  - [ ] Search codebase for all MessageEntity initializer calls
  - [ ] Verify new optional parameters don't break existing code
  - [ ] Build project to verify no compilation errors

- [ ] Test SwiftData migration (AC: 2, 5)
  - [ ] Before making changes, note current app version
  - [ ] Make MessageEntity changes and rebuild
  - [ ] Delete app from simulator to test fresh install
  - [ ] Build and run app in simulator
  - [ ] Verify app launches without migration errors
  - [ ] Check Xcode console for SwiftData migration logs
  - [ ] Install app over existing version (migration test)
  - [ ] Verify existing messages still load correctly with nil AI metadata

- [ ] Update RTDB sync to write AI metadata (AC: 3)
  - [ ] Open `buzzbox/Core/Services/RealtimeDBService.swift`
  - [ ] Find `syncMessage(_:)` method
  - [ ] Add AI metadata to the data dictionary:
    - `if let aiCategory = message.aiCategory { data["aiCategory"] = aiCategory }`
    - `if let aiSentiment = message.aiSentiment { data["aiSentiment"] = aiSentiment }`
    - `if let aiOpportunityScore = message.aiOpportunityScore { data["aiOpportunityScore"] = aiOpportunityScore }`
    - `data["isAIGenerated"] = message.isAIGenerated`
    - `if let aiProcessedAt = message.aiProcessedAt { data["aiProcessedAt"] = aiProcessedAt.timeIntervalSince1970 }`

- [ ] Update RTDB observer to handle new and updated messages (AC: 4)
  - [ ] Find or create `observeMessageUpdates(conversationId:handler:)` method
  - [ ] Listen for `.childAdded` events (new messages)
  - [ ] Listen for `.childChanged` events (AI metadata updates)
  - [ ] Extract AI metadata parsing into helper method (reused for both observers)
  - [ ] Helper method handles null timestamps: use `Date()` if timestamp missing
  - [ ] Parse AI metadata with null safety:
    - `aiCategory: dict["aiCategory"] as? String`
    - `aiSentiment: dict["aiSentiment"] as? String`
    - `aiOpportunityScore: dict["aiOpportunityScore"] as? Int`
    - `isAIGenerated: dict["isAIGenerated"] as? Bool ?? false`
    - `aiProcessedAt: (dict["aiProcessedAt"] as? TimeInterval).map { Date(timeIntervalSince1970: $0) }`
  - [ ] Validate required fields (id, text, senderId) exist before creating MessageEntity
  - [ ] Update MessageEntity in SwiftData with new AI metadata
  - [ ] Trigger UI update via SwiftData change notifications

- [ ] Add AI metadata null safety and validation
  - [ ] Wrap AI metadata parsing in optional binding
  - [ ] Log warning if metadata exists but can't be parsed
  - [ ] Don't fail entire message parsing if AI metadata is invalid
  - [ ] Validate aiOpportunityScore is in range 0-100 if present
  - [ ] Skip malformed AI metadata values gracefully

- [ ] Update all message creation points
  - [ ] Search codebase for all MessageEntity initializer calls
  - [ ] Verify new optional AI metadata parameters don't break existing code
  - [ ] When sending FAQ auto-response (Story 6.3.5), set `isAIGenerated: true`
  - [ ] For normal user messages, `isAIGenerated` defaults to `false`
  - [ ] Document where and when `isAIGenerated` should be set to `true`
  - [ ] Build and test to ensure all message sends still work

- [ ] Verify backward compatibility (AC: 5)
  - [ ] Existing messages without AI metadata will have `nil` values
  - [ ] SwiftData handles optional fields automatically
  - [ ] No data migration script needed (optional fields auto-migrate)
  - [ ] UI components check for `nil` before displaying AI badges

- [ ] Test AI metadata flow end-to-end (AC: 6)
  - [ ] Send test message from iOS app
  - [ ] Cloud Function (Story 6.2) auto-processes message
  - [ ] RTDB observer receives AI metadata update
  - [ ] SwiftData updates MessageEntity
  - [ ] Verify AI metadata appears in iOS app (will be displayed in Story 6.7)
  - [ ] Check Firebase Console > RTDB to see AI metadata on message

## Dev Notes

### Architecture Context

**Data Models** [Source: architecture/data-architecture.md#4.1]
- Message includes AI Metadata: category, sentiment, opportunityScore, faqMatch, smartReplyDraft
- SwiftData uses `@Model` classes for local persistence
- MessageEntity: Message content, AI metadata, sync status

**SwiftData Schema** [Source: architecture/data-architecture.md#4.2]
- MessageEntity is a `@Model` class with SwiftData
- Relationships: ConversationEntity → [MessageEntity] (one-to-many, cascade delete)
- SwiftData automatically handles schema changes for optional fields

**SwiftData ↔ RTDB Sync Strategy** [Source: architecture/data-architecture.md#4.4]
- Write Path: Write to SwiftData immediately, sync to RTDB in background
- Read Path: Fetch from SwiftData first, update from RTDB in background
- Cloud Functions update RTDB, which triggers RTDB observers, which update SwiftData
- SwiftData change notifications trigger UI updates automatically

**Database Strategy** [Source: architecture/technology-stack.md#2.2]
- Real-time Database: Firebase Realtime Database (Chat messages, typing indicators, presence)
- Important: Messages are stored in RTDB, not Firestore
- Cloud Functions update RTDB with AI metadata
- iOS app observes RTDB for changes

### File Locations

**Files to Modify:**
- `buzzbox/Core/Models/MessageEntity.swift` - Add AI metadata properties
- `buzzbox/Core/Services/RealtimeDBService.swift` - Update sync to include AI metadata

### MessageEntity Structure (Updated)

**Before (Existing):**
```swift
@Model
final class MessageEntity {
    var id: String
    var conversationID: String
    var senderID: String
    var text: String
    var timestamp: Date
    var status: MessageStatus
    var readBy: [String]

    // Existing initializer
}
```

**After (With AI Metadata):**
```swift
@Model
final class MessageEntity {
    // EXISTING FIELDS (keep all)
    var id: String
    var conversationID: String
    var senderID: String
    var text: String
    var timestamp: Date
    var status: MessageStatus
    var readBy: [String]

    // NEW: AI Metadata Fields
    var aiCategory: String?           // "fan" | "business" | "spam" | "urgent"
    var aiSentiment: String?          // "positive" | "negative" | "urgent" | "neutral"
    var aiOpportunityScore: Int?      // 0-100 (only for business)
    var isAIGenerated: Bool = false   // True if FAQ auto-response
    var aiProcessedAt: Date?          // When AI processing completed

    init(
        id: String = UUID().uuidString,
        conversationID: String,
        senderID: String,
        text: String,
        timestamp: Date = Date(),
        status: MessageStatus = .sending,
        readBy: [String] = [],
        // AI metadata (optional)
        aiCategory: String? = nil,
        aiSentiment: String? = nil,
        aiOpportunityScore: Int? = nil,
        isAIGenerated: Bool = false,
        aiProcessedAt: Date? = nil
    ) {
        self.id = id
        self.conversationID = conversationID
        self.senderID = senderID
        self.text = text
        self.timestamp = timestamp
        self.status = status
        self.readBy = readBy
        self.aiCategory = aiCategory
        self.aiSentiment = aiSentiment
        self.aiOpportunityScore = aiOpportunityScore
        self.isAIGenerated = isAIGenerated
        self.aiProcessedAt = aiProcessedAt
    }
}
```

### RTDB Sync Implementation

**Write AI Metadata (syncMessage method):**
```swift
func syncMessage(_ message: MessageEntity) async throws {
    let messageRef = database.child("messages")
        .child(message.conversationID)
        .child(message.id)

    var data: [String: Any] = [
        "id": message.id,
        "text": message.text,
        "senderID": message.senderID,
        "timestamp": ServerValue.timestamp(),
        "status": message.status.rawValue,
        "readBy": message.readBy,
    ]

    // AI Metadata (optional fields)
    if let aiCategory = message.aiCategory {
        data["aiCategory"] = aiCategory
    }
    if let aiSentiment = message.aiSentiment {
        data["aiSentiment"] = aiSentiment
    }
    if let aiOpportunityScore = message.aiOpportunityScore {
        data["aiOpportunityScore"] = aiOpportunityScore
    }
    data["isAIGenerated"] = message.isAIGenerated
    if let aiProcessedAt = message.aiProcessedAt {
        data["aiProcessedAt"] = aiProcessedAt.timeIntervalSince1970
    }

    try await messageRef.setValue(data)
}
```

**Read AI Metadata (observeMessageUpdates method):**
```swift
func observeMessageUpdates(conversationId: String, handler: @escaping (MessageEntity) -> Void) {
    let messagesRef = database.child("messages").child(conversationId)

    messagesRef.observe(.childChanged) { snapshot in
        guard let dict = snapshot.value as? [String: Any] else { return }

        // Parse AI metadata
        let message = MessageEntity(
            id: dict["id"] as? String ?? "",
            conversationID: conversationId,
            senderID: dict["senderID"] as? String ?? "",
            text: dict["text"] as? String ?? "",
            timestamp: Date(timeIntervalSince1970: dict["timestamp"] as? TimeInterval ?? 0),
            status: MessageStatus(rawValue: dict["status"] as? String ?? "sent") ?? .sent,
            readBy: dict["readBy"] as? [String] ?? [],
            aiCategory: dict["aiCategory"] as? String,
            aiSentiment: dict["aiSentiment"] as? String,
            aiOpportunityScore: dict["aiOpportunityScore"] as? Int,
            isAIGenerated: dict["isAIGenerated"] as? Bool ?? false,
            aiProcessedAt: (dict["aiProcessedAt"] as? TimeInterval).map { Date(timeIntervalSince1970: $0) }
        )

        handler(message)
    }
}
```

### SwiftData Migration

**Automatic Migration:**
- SwiftData automatically handles schema changes when properties are added
- Optional properties (`String?`, `Int?`, `Date?`) are safe to add
- Non-optional properties with defaults (`Bool = false`) are safe to add
- Existing messages will have `nil` for new optional fields
- No migration code needed!

**What Happens:**
1. App launches with updated MessageEntity schema
2. SwiftData detects schema change
3. SwiftData adds new columns to SQLite database
4. Existing rows get `NULL` for new optional columns
5. Existing rows get `false` for `isAIGenerated`
6. App continues working normally

### Integration Flow

**How AI Metadata Flows from Cloud Functions to iOS:**
1. User sends message → Saved to RTDB via iOS app
2. Cloud Function (Story 6.2) triggers on RTDB write
3. Cloud Function processes message with AI (categorization, sentiment, scoring)
4. Cloud Function updates RTDB message with AI metadata
5. iOS app observes RTDB `.childChanged` event
6. iOS app updates SwiftData MessageEntity with AI metadata
7. SwiftData change notification triggers UI update
8. UI displays AI badges (Story 6.7)

### Testing

**Testing Approach:**
1. Update MessageEntity and RTDB sync code
2. Build and run iOS app (verify no migration errors)
3. Send test message from iOS app
4. Wait for Cloud Function to process (~1-2 seconds)
5. Check Firebase Console > RTDB to see AI metadata
6. Verify iOS app receives AI metadata update
7. Check SwiftData in Xcode debugger to see AI metadata on message

**Test Cases:**
- New message: Verify AI metadata appears within 1-2 seconds
- Existing message: Verify nil AI metadata doesn't crash app
- FAQ auto-response: Verify `isAIGenerated: true`
- Business message: Verify `aiOpportunityScore` is populated
- Non-business message: Verify `aiOpportunityScore` is nil

**Testing Standards** [Source: architecture/testing-strategy.md - assumed]
- Manual testing via iOS app
- Verify SwiftData migration succeeds
- Verify RTDB sync includes AI metadata
- Verify AI metadata updates propagate from Cloud Functions
- No unit tests required for data model changes

### Important Notes

- This story updates the data layer only
- No UI changes in this story (UI happens in Story 6.7)
- AI metadata is optional - messages work without it
- SwiftData handles migration automatically
- Backward compatible with existing messages
- Cloud Function updates are real-time (<1s latency)

### Prerequisites

- Stories 6.0-6.4 (Cloud Functions) must be deployed
- Story 6.2 (Auto-Processing) must be working
- RTDB must be accessible from iOS app
- SwiftData must be configured in app

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-22 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be populated by dev agent*

### Debug Log References

*To be populated by dev agent*

### Completion Notes

*To be populated by dev agent*

### File List

*To be populated by dev agent*

## QA Results

*This section will be populated by the QA agent after story completion.*
