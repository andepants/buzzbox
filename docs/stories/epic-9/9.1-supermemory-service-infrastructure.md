# Story 9.1: Supermemory Service Infrastructure (iOS Client)

**Epic:** Epic 9 - Supermemory RAG Integration
**Story ID:** 9.1
**Priority:** P1 (High)
**Estimated Time:** 2-3 hours
**Dependencies:** Story 9.0 (Firebase Functions Setup)
**Status:** Draft

---

## üìñ User Story

**As a** developer integrating RAG capabilities,
**I want** an iOS service layer that communicates with Firebase Cloud Functions for Supermemory,
**So that** I can add and search memories securely without exposing API keys in the client app.

---

## üéØ Acceptance Criteria

### Functional Requirements

1. **Service Implementation**
   - [ ] Create `SupermemoryService.swift` in `Core/Services/` directory
   - [ ] Implement singleton pattern with `shared` instance
   - [ ] Use `@MainActor` for thread safety
   - [ ] Implement `ObservableObject` protocol for state observation

2. **Add Memory Method**
   - [ ] Implement `addMemory(content: String, metadata: [String: String]?) async throws`
   - [ ] Call Firebase Cloud Function `addSupermemoryMemory`
   - [ ] Use Firebase callable functions (not HTTP requests)
   - [ ] Handle 200-299 status codes as success
   - [ ] Throw descriptive errors for failures
   - [ ] **NO direct API calls to Supermemory**
   - [ ] **NO API key in iOS code**

3. **Search Memories Method**
   - [ ] Implement `searchMemories(query: String, limit: Int = 3) async throws -> [Memory]`
   - [ ] Call Firebase Cloud Function `searchSupermemoryMemories`
   - [ ] Parse response into `Memory` model array
   - [ ] Apply 2-second timeout with graceful fallback
   - [ ] Return empty array on timeout (don't throw)

4. **Configuration Management**
   - [ ] Implement `isEnabled: Bool` computed property
   - [ ] Check if user is creator (via AuthService)
   - [ ] **NO Keychain API key storage** (API key in Firebase)
   - [ ] **NO API key configuration in iOS app**

5. **Memory Model**
   - [ ] Create `Memory` struct in `Core/Models/Memory.swift`
   - [ ] Properties: `id: String`, `content: String`, `metadata: [String: String]?`, `score: Double?`
   - [ ] Conform to `Codable` and `Identifiable`

### Technical Requirements

6. **Swift Concurrency**
   - [ ] Use `async/await` for all API calls (no completion handlers)
   - [ ] Use Firebase Functions SDK for callable functions
   - [ ] Properly handle `Task` cancellation

7. **Error Handling**
   - [ ] Define `SupermemoryError` enum with cases:
     - `notConfigured` - User not creator
     - `invalidResponse` - Non-200 status code from function
     - `decodingError(Error)` - JSON parsing failed
     - `networkError(Error)` - Firebase Functions error
     - `timeout` - Request exceeded timeout
   - [ ] Throw specific errors (don't swallow exceptions)
   - [ ] Handle Firebase Functions error codes properly

8. **Firebase Integration**
   - [ ] Use `Firebase Functions` SDK for callable functions
   - [ ] Import `FirebaseFunctions` module
   - [ ] Use `Functions.functions()` instance
   - [ ] Use `.httpsCallable()` for function calls
   - [ ] Handle `FunctionsErrorCode` enum

### Quality Requirements

9. **Code Quality**
   - [ ] Add `///` doc comments to all public methods
   - [ ] Follow existing `AIService.swift` patterns
   - [ ] Keep file under 300 lines
   - [ ] Use descriptive variable names

10. **Testing**
    - [ ] Service initializes correctly
    - [ ] `isEnabled` returns false when not creator
    - [ ] `isEnabled` returns true when creator
    - [ ] Methods throw `notConfigured` error when disabled
    - [ ] Firebase Functions called (not direct Supermemory API)

---

## üîß Technical Implementation Notes

### API Architecture (SECURE)

**‚ùå OLD (INSECURE):**
```
iOS App ‚Üí Direct API calls ‚Üí Supermemory API
        ‚Üë API key in Keychain (EXPOSED)
```

**‚úÖ NEW (SECURE):**
```
iOS App ‚Üí Firebase Callable Functions ‚Üí Supermemory API
                  ‚Üë
          API key in Firebase (SECURE)
```

### File Structure

```
buzzbox/
‚îú‚îÄ‚îÄ Core/
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Memory.swift          # NEW: Memory data model
‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îú‚îÄ‚îÄ SupermemoryService.swift  # NEW: Main service (uses Functions)
‚îÇ       ‚îî‚îÄ‚îÄ AIService.swift           # REFERENCE: Similar patterns
```

### Code Implementation

**File:** `Core/Services/SupermemoryService.swift`

```swift
import Foundation
import FirebaseFunctions

/// Service for managing Supermemory RAG integration via Firebase Cloud Functions
/// Note: API key is stored securely in Firebase, never in the iOS app
/// Provides secure access to memory storage and search functionality
@MainActor
final class SupermemoryService: ObservableObject {
    static let shared = SupermemoryService()

    // Firebase Functions instance
    private let functions = Functions.functions()

    // Published properties for UI observation
    @Published private(set) var totalMemoriesStored: Int = 0
    @Published private(set) var lastSyncDate: Date?
    @Published private(set) var pendingMemoriesCount: Int = 0

    private init() {}

    // MARK: - Configuration

    /// Check if Supermemory is enabled for current user
    /// Only creator (Andrew) can use Supermemory features
    var isEnabled: Bool {
        return AuthService.shared.isCreator
    }

    // MARK: - Memory Operations

    /// Add a memory to Supermemory via Firebase Cloud Function
    /// - Parameters:
    ///   - content: The Q&A content to store
    ///   - metadata: Optional metadata (conversationID, timestamp, etc.)
    /// - Throws: SupermemoryError if operation fails
    func addMemory(content: String, metadata: [String: String]? = nil) async throws {
        guard isEnabled else {
            throw SupermemoryError.notConfigured
        }

        // Validate input
        guard !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw SupermemoryError.invalidContent
        }

        // Call Firebase Cloud Function (API key secure on server)
        let callable = functions.httpsCallable("addSupermemoryMemory")

        let data: [String: Any] = [
            "content": content,
            "metadata": metadata ?? [:]
        ]

        do {
            let result = try await callable.call(data)

            // Parse response
            guard let resultData = result.data as? [String: Any],
                  let success = resultData["success"] as? Bool,
                  success else {
                throw SupermemoryError.invalidResponse(statusCode: 500)
            }

            print("‚úÖ Memory stored via Cloud Function")

            // Update stats
            totalMemoriesStored += 1
            lastSyncDate = Date()

        } catch let error as NSError {
            // Handle Firebase Functions errors
            if error.domain == FunctionsErrorDomain {
                let code = FunctionsErrorCode(rawValue: error.code)
                let message = error.localizedDescription

                print("‚ö†Ô∏è Cloud Function error: \(message)")

                // Classify error for proper handling
                switch code {
                case .unauthenticated:
                    throw SupermemoryError.notConfigured
                case .permissionDenied:
                    throw SupermemoryError.notConfigured
                case .invalidArgument:
                    throw SupermemoryError.invalidContent
                case .deadlineExceeded:
                    throw SupermemoryError.timeout
                default:
                    throw SupermemoryError.networkError(error)
                }
            }

            throw SupermemoryError.networkError(error)
        }
    }

    /// Search memories in Supermemory via Firebase Cloud Function
    /// - Parameters:
    ///   - query: Search query text
    ///   - limit: Maximum number of results (default: 3)
    /// - Returns: Array of Memory objects, empty on failure (graceful degradation)
    func searchMemories(query: String, limit: Int = 3) async throws -> [Memory] {
        guard isEnabled else {
            return [] // Graceful fallback
        }

        // Validate input
        guard !query.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            return []
        }

        let callable = functions.httpsCallable("searchSupermemoryMemories")

        let data: [String: Any] = [
            "query": query,
            "limit": limit
        ]

        do {
            // Apply timeout using Task
            let result = try await withTimeout(seconds: 2) {
                try await callable.call(data)
            }

            // Parse response
            guard let resultData = result.data as? [String: Any],
                  let memoriesArray = resultData["memories"] as? [[String: Any]] else {
                print("‚ö†Ô∏è Invalid response format from Cloud Function")
                return []
            }

            // Convert to Memory objects
            let memories = memoriesArray.compactMap { dict -> Memory? in
                guard let id = dict["id"] as? String,
                      let content = dict["content"] as? String else {
                    return nil
                }

                let metadata = dict["metadata"] as? [String: String]
                let score = dict["score"] as? Double

                return Memory(id: id, content: content, metadata: metadata, score: score)
            }

            print("‚úÖ Found \(memories.count) memories via Cloud Function")
            return memories

        } catch {
            // Graceful degradation: return empty array on any error
            print("‚ö†Ô∏è Search failed: \(error.localizedDescription)")
            return []
        }
    }

    // MARK: - Utilities

    /// Execute async operation with timeout
    private func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {
        try await withThrowingTaskGroup(of: T.self) { group in
            // Add actual operation
            group.addTask {
                try await operation()
            }

            // Add timeout task
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                throw SupermemoryError.timeout
            }

            // Return first result, cancel others
            let result = try await group.next()!
            group.cancelAll()
            return result
        }
    }
}

// MARK: - Error Types

/// Error types for Supermemory operations
enum SupermemoryError: LocalizedError {
    case notConfigured
    case invalidContent
    case invalidResponse(statusCode: Int)
    case decodingError(Error)
    case networkError(Error)
    case timeout

    var errorDescription: String? {
        switch self {
        case .notConfigured:
            return "Supermemory not configured or user not authorized"
        case .invalidContent:
            return "Content cannot be empty"
        case .invalidResponse(let code):
            return "Invalid response: \(code)"
        case .decodingError(let error):
            return "Decoding failed: \(error.localizedDescription)"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .timeout:
            return "Request timeout"
        }
    }
}
```

### Memory Model Implementation

**File:** `Core/Models/Memory.swift`

```swift
import Foundation

/// Represents a memory retrieved from Supermemory via Firebase Cloud Functions
/// Used for RAG (Retrieval-Augmented Generation) context in AI drafts
struct Memory: Identifiable, Codable {
    /// Unique identifier for the memory
    let id: String

    /// The memory content (typically Q&A format)
    let content: String

    /// Optional metadata (conversationID, timestamp, category, etc.)
    let metadata: [String: String]?

    /// Relevance score from search (0.0 to 1.0)
    let score: Double?

    enum CodingKeys: String, CodingKey {
        case id
        case content
        case metadata
        case score
    }
}
```

---

## üîó Related Files

- **Dependency:** Story 9.0 - Firebase Functions must be deployed first
- **Reference:** `Core/Services/AIService.swift` - Follow similar patterns for service
- **New:** `Core/Models/Memory.swift` - Memory data model
- **New:** `Core/Services/SupermemoryService.swift` - Main service file
- **Reference:** `Core/Services/AuthService.swift` - Check if creator

---

## üìã Definition of Done

- [ ] Story 9.0 completed (Firebase Functions deployed)
- [ ] `SupermemoryService.swift` created with all required methods
- [ ] `Memory.swift` model created with proper Codable conformance
- [ ] All acceptance criteria met and tested
- [ ] Code compiles without warnings
- [ ] Doc comments added to all public APIs
- [ ] Follows Swift 6 concurrency patterns
- [ ] **NO API key in iOS code** (verified)
- [ ] **NO Keychain API key storage** (verified)
- [ ] Uses Firebase callable functions
- [ ] Error handling implemented with specific error types
- [ ] Code reviewed against existing service patterns
- [ ] Tested with Firebase Functions (local emulator and production)

---

## ‚ö†Ô∏è Important Notes

1. **Security First:** API key NEVER in iOS app - always in Firebase Functions
2. **Graceful Degradation:** Service must fail gracefully if functions unavailable
3. **No Blocking:** Never block the main thread waiting for function responses
4. **Timeout Handling:** Search must timeout after 2 seconds to prevent UI hangs
5. **Creator Only:** Only Andrew can store/search memories (enforced server-side)
6. **Future-Proofing:** Design allows for easy addition of other Supermemory endpoints

---

## üîç Testing Guidance

**Manual Testing Steps:**

1. **Test 9.0 Completed**
   - [ ] Verify Firebase Functions deployed
   - [ ] Verify `SUPERMEMORY_API_KEY` secret configured
   - [ ] Test functions with emulator first

2. **Test Service Initialization**
   - [ ] Run app as non-creator ‚Üí `isEnabled` should be false
   - [ ] Run app as Andrew (creator) ‚Üí `isEnabled` should be true

3. **Test Add Memory**
   - [ ] Call `addMemory()` with test content
   - [ ] Verify Cloud Function called (check Firebase logs)
   - [ ] Verify NO direct Supermemory API call
   - [ ] Check console: "‚úÖ Memory stored via Cloud Function"

4. **Test Search Memories**
   - [ ] Call `searchMemories()` with query
   - [ ] Verify results returned
   - [ ] Test with timeout (network delay)
   - [ ] Verify graceful fallback on errors

5. **Test Error Handling**
   - [ ] Test as non-creator ‚Üí should get notConfigured error
   - [ ] Test with empty content ‚Üí should get invalidContent error
   - [ ] Test with network disconnected ‚Üí should get timeout/network error

6. **Security Verification**
   - [ ] Search Xcode project for "supermemory" API key ‚Üí should NOT find any
   - [ ] Check Keychain ‚Üí should have NO Supermemory key
   - [ ] Decompile app ‚Üí should have NO API key strings

**Edge Cases:**
- Empty content string
- Nil metadata
- Very long content (>10KB)
- Network interruption mid-request
- Firebase Functions rate limiting
- Creator authorization changes

---

## üéì Architecture Benefits

### Security Comparison

| Aspect | ‚ùå Old (Direct API) | ‚úÖ New (Cloud Functions) |
|--------|---------------------|--------------------------|
| **API Key Storage** | iOS Keychain (extractable) | Firebase (secure) |
| **Access Control** | Client-side (bypassable) | Server-side (enforced) |
| **Rate Limiting** | None | Firebase + Supermemory |
| **Audit Trail** | Limited | Full Cloud Logging |
| **Key Rotation** | Requires app update | Update Firebase secret |
| **Code Complexity** | More (URLSession, Keychain) | Less (callable functions) |

### Why This is Better

1. **Security**: API key never leaves Firebase servers
2. **Authorization**: Creator-only access enforced server-side
3. **Simplicity**: Firebase SDK handles auth, retries, timeouts
4. **Monitoring**: All calls logged in Cloud Logging
5. **Scalability**: Firebase handles rate limiting and scaling
6. **Maintenance**: Update functions without app updates

---

## üöÄ Implementation Order

1. **First:** Complete Story 9.0 (deploy Firebase Functions)
2. **Then:** Implement `Memory.swift` model (5 min)
3. **Then:** Implement `SupermemoryService.swift` (90 min)
4. **Then:** Test with Firebase Emulator (30 min)
5. **Then:** Test with production Firebase Functions (15 min)
6. **Finally:** Security verification (15 min)

---

**Created by:** Product Owner (PO Agent)
**Date:** 2025-10-26
**Updated:** Revised to use Firebase Cloud Functions for security
**Depends on:** Story 9.0 (Firebase Functions setup)
