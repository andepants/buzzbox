# Story 9.0: Supermemory Cloud Functions Implementation

**Epic:** Epic 9 - Supermemory RAG Integration
**Story ID:** 9.0
**Priority:** P0 (Critical - Foundation)
**Estimated Time:** 1.5-2 hours
**Dependencies:** None (Firebase Functions already configured)
**Status:** Draft

> **Production Note:** Firebase Functions is already set up in `buzzbox-ios` project with Node 20, TypeScript, and Firebase Functions v2. The `SUPERMEMORY_API_KEY` secret is already configured. This story focuses on ADDING the Supermemory callable functions to the existing setup.

---

## üìñ User Story

**As a** developer implementing RAG capabilities,
**I want** Firebase Cloud Functions to securely proxy Supermemory API calls,
**So that** the Supermemory API key remains secure on the server and is never exposed in the iOS client app.

---

## üéØ Current Production Setup

‚úÖ **Already Configured:**
- Firebase project: `buzzbox-ios`
- Node 20 runtime
- TypeScript configured
- Firebase Functions v2 (firebase-functions 5.0.0)
- firebase-admin 12.0.0
- OpenAI integration working (OPENAI_API_KEY secret configured)
- Existing functions: onMessageCreated, processMessageAI, checkFAQ, generateSmartReplies, analyzeConversation
- **SUPERMEMORY_API_KEY secret already configured** ‚úÖ

‚ùå **To Be Added:**
- `addSupermemoryMemory` callable function
- `searchSupermemoryMemories` callable function
- Supermemory integration code

---

## üéØ Acceptance Criteria

### Functional Requirements

1. **Verify Existing Setup**
   - [x] Firebase Functions already initialized ‚úÖ
   - [x] TypeScript already configured ‚úÖ
   - [x] Directory structure exists (`functions/src/`) ‚úÖ
   - [x] Required npm dependencies installed ‚úÖ
   - [x] SUPERMEMORY_API_KEY secret already configured ‚úÖ

2. **Create Supermemory Functions File**
   - [ ] Create `functions/src/supermemory.ts` (new file)
   - [ ] Follow existing code patterns from `ai-processing.ts`, `faq.ts`, etc.
   - [ ] Use Firebase Functions v2 API (onCall)
   - [ ] Import required modules (admin, logger, etc.)

3. **Add Memory Cloud Function**
   - [ ] Create `addSupermemoryMemory` callable function
   - [ ] Implement authentication check
   - [ ] Implement creator-only authorization (andrewsheim@gmail.com)
   - [ ] POST to Supermemory `/add` endpoint
   - [ ] Return success response with memory ID
   - [ ] Handle errors with proper error codes

4. **Search Memories Cloud Function**
   - [ ] Create `searchSupermemoryMemories` callable function
   - [ ] Implement authentication check
   - [ ] POST to Supermemory `/search` endpoint
   - [ ] Return array of memories
   - [ ] Implement 10-second timeout
   - [ ] Graceful fallback on errors (return empty array)

5. **Security Requirements**
   - [ ] Enforce user authentication on all functions
   - [ ] Verify creator email server-side
   - [ ] Never log API key (even in debug logs)
   - [ ] Use HTTPS only (automatic with Firebase)
   - [ ] Configure CORS if needed

### Technical Requirements

6. **Function Configuration**
   - [ ] Set region: `us-central1`
   - [ ] Configure secrets access
   - [ ] Set appropriate timeout limits
   - [ ] Enable structured logging

7. **Error Handling**
   - [ ] Return proper `HttpsError` codes:
     - `unauthenticated` - User not signed in
     - `permission-denied` - User not creator
     - `internal` - Supermemory API failure
   - [ ] Log all errors to Cloud Logging
   - [ ] Don't expose internal error details to clients

8. **Testing**
   - [ ] Test functions locally with Firebase Emulator
   - [ ] Test with valid creator authentication
   - [ ] Test with non-creator user (should fail)
   - [ ] Test with unauthenticated request (should fail)
   - [ ] Deploy to Firebase and test from production

### Quality Requirements

9. **Code Quality**
   - [ ] Add JSDoc comments to all functions
   - [ ] Follow TypeScript best practices
   - [ ] Use structured logging with `firebase-functions/logger`
   - [ ] Keep functions under 100 lines each

10. **Documentation**
    - [ ] Document deployment process
    - [ ] Document local testing with emulator
    - [ ] Document secret configuration steps

---

## üîß Technical Implementation

### Directory Structure

```
buzzbox/
‚îú‚îÄ‚îÄ functions/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts          # NEW: Cloud Functions
‚îÇ   ‚îú‚îÄ‚îÄ package.json           # NEW: Dependencies
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json          # NEW: TypeScript config
‚îÇ   ‚îî‚îÄ‚îÄ .gitignore            # NEW: Ignore node_modules, etc.
‚îî‚îÄ‚îÄ firebase.json              # MODIFY: Add functions config
```

### New Supermemory Functions File

**File:** `functions/src/supermemory.ts` (NEW FILE)

```typescript
/**
 * Supermemory RAG Integration for Buzzbox
 *
 * Provides secure server-side access to Supermemory API for:
 * - Storing Q&A pairs from creator replies
 * - Searching memories for AI context enhancement
 *
 * API Key: Stored securely in Firebase as SUPERMEMORY_API_KEY secret
 * Authorization: Creator-only access enforced server-side
 *
 * [Source: Story 9.0 - Supermemory Cloud Functions]
 */

import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";

// Supermemory API configuration
const SUPERMEMORY_BASE_URL = "https://v2.api.supermemory.ai";
const CREATOR_EMAIL = "andrewsheim@gmail.com";

// Interfaces for type safety
interface AddMemoryRequest {
  content: string;
  metadata?: Record<string, string>;
}

interface AddMemoryResponse {
  success: boolean;
  memoryId?: string;
  timestamp: string;
}

interface SearchMemoriesRequest {
  query: string;
  limit?: number;
}

interface SearchMemoriesResponse {
  memories: Array<{
    id: string;
    content: string;
    metadata?: Record<string, string>;
    score?: number;
  }>;
  searchedAt: string;
}

/**
 * Adds a memory to Supermemory API.
 * Only accessible by authenticated creator.
 * API key stored securely as Firebase secret.
 */
export const addSupermemoryMemory = onCall<AddMemoryRequest, Promise<AddMemoryResponse>>({
  region: "us-central1",
  secrets: ["SUPERMEMORY_API_KEY"],
  timeoutSeconds: 30
}, async (request) => {
  logger.info("addSupermemoryMemory invoked", {
    uid: request.auth?.uid,
    hasContent: !!request.data.content
  });

  // Check authentication
  if (!request.auth) {
    logger.warn("Unauthenticated request");
    throw new HttpsError("unauthenticated", "Must be signed in to store memories");
  }

  // Check creator authorization
  const userEmail = request.auth.token.email;
  if (userEmail !== CREATOR_EMAIL) {
    logger.warn("Unauthorized user attempted to store memory", {
      uid: request.auth.uid,
      email: userEmail
    });
    throw new HttpsError("permission-denied", "Only creator can store memories");
  }

  const { content, metadata } = request.data;

  // Validate input
  if (!content || content.trim().length === 0) {
    throw new HttpsError("invalid-argument", "Content cannot be empty");
  }

  try {
    // Call Supermemory API (server-side, API key secure)
    const apiKey = process.env.SUPERMEMORY_API_KEY;
    if (!apiKey) {
      logger.error("SUPERMEMORY_API_KEY not configured");
      throw new HttpsError("internal", "Service configuration error");
    }

    logger.info("Calling Supermemory API", {
      contentLength: content.length,
      hasMetadata: !!metadata
    });

    const response = await fetch(`${SUPERMEMORY_BASE_URL}/add`, {
      method: "POST",
      headers: {
        "x-api-key": apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        content,
        metadata: metadata || {}
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      logger.error("Supermemory API error", {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      throw new HttpsError("internal", `Supermemory API error: ${response.status}`);
    }

    const result = await response.json();

    logger.info("Memory stored successfully", {
      memoryId: result.id,
      uid: request.auth.uid
    });

    return {
      success: true,
      memoryId: result.id,
      timestamp: new Date().toISOString()
    };

  } catch (error: any) {
    // Don't expose internal errors to client
    if (error instanceof HttpsError) {
      throw error;
    }

    logger.error("Failed to store memory", {
      error: error.message,
      stack: error.stack,
      uid: request.auth.uid
    });

    throw new HttpsError("internal", "Failed to store memory");
  }
});

/**
 * Searches memories in Supermemory API.
 * Accessible by all authenticated users.
 * Returns empty array on errors for graceful degradation.
 */
export const searchSupermemoryMemories = onCall<SearchMemoriesRequest, Promise<SearchMemoriesResponse>>({
  region: "us-central1",
  secrets: ["SUPERMEMORY_API_KEY"],
  timeoutSeconds: 10 // 10 second timeout for search
}, async (request) => {
  logger.info("searchSupermemoryMemories invoked", {
    uid: request.auth?.uid,
    query: request.data.query?.substring(0, 50) // Log first 50 chars
  });

  // Check authentication
  if (!request.auth) {
    logger.warn("Unauthenticated search request");
    throw new HttpsError("unauthenticated", "Must be signed in to search memories");
  }

  const { query, limit = 3 } = request.data;

  // Validate input
  if (!query || query.trim().length === 0) {
    logger.warn("Empty query provided");
    return {
      memories: [],
      searchedAt: new Date().toISOString()
    };
  }

  try {
    const apiKey = process.env.SUPERMEMORY_API_KEY;
    if (!apiKey) {
      logger.error("SUPERMEMORY_API_KEY not configured");
      // Graceful degradation: return empty results
      return {
        memories: [],
        searchedAt: new Date().toISOString()
      };
    }

    logger.info("Searching Supermemory", {
      queryLength: query.length,
      limit
    });

    const response = await fetch(`${SUPERMEMORY_BASE_URL}/search`, {
      method: "POST",
      headers: {
        "x-api-key": apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ query, limit })
    });

    if (!response.ok) {
      logger.warn("Supermemory search API error", {
        status: response.status,
        statusText: response.statusText
      });
      // Graceful degradation: return empty results
      return {
        memories: [],
        searchedAt: new Date().toISOString()
      };
    }

    const result = await response.json();
    const memories = result.memories || result.results || [];

    logger.info("Search completed successfully", {
      resultCount: memories.length,
      uid: request.auth.uid
    });

    return {
      memories: memories.map((m: any) => ({
        id: m.id || m._id || String(Math.random()),
        content: m.content || m.text || "",
        metadata: m.metadata,
        score: m.score || m.similarity
      })),
      searchedAt: new Date().toISOString()
    };

  } catch (error: any) {
    // Graceful degradation: don't throw, return empty
    logger.error("Search failed", {
      error: error.message,
      stack: error.stack,
      uid: request.auth.uid
    });

    return {
      memories: [],
      searchedAt: new Date().toISOString()
    };
  }
});
```

### Update index.ts to Export New Functions

**File:** `functions/src/index.ts` (ADD TO EXISTING FILE)

At the top with other exports, add:

```typescript
// Export Supermemory functions (NEW - Epic 9)
export {addSupermemoryMemory, searchSupermemoryMemories} from "./supermemory";
```

### Existing package.json (NO CHANGES NEEDED)

**File:** `functions/package.json`

‚úÖ Already configured correctly:
- Node 20 engine
- firebase-admin 12.0.0
- firebase-functions 5.0.0
- TypeScript
- All required scripts

**No changes needed** - existing dependencies support Supermemory integration.

---

## üìã Implementation Steps

### Step 1: Verify Existing Setup (5 min)

```bash
cd /Users/andre/coding/buzzbox

# ‚úÖ Verify Firebase project
cat .firebaserc
# Should show: buzzbox-ios

# ‚úÖ Verify SUPERMEMORY_API_KEY secret exists
firebase functions:secrets:access SUPERMEMORY_API_KEY
# Should return the API key value

# ‚úÖ Verify existing functions
ls functions/src/
# Should show: index.ts, ai-processing.ts, faq.ts, etc.
```

### Step 2: Create Supermemory Functions File (30 min)

```bash
# Create new file
touch functions/src/supermemory.ts

# Copy the implementation from the code template above
# Follow existing patterns from ai-processing.ts and faq.ts
```

### Step 3: Update index.ts Exports (5 min)

Add to `functions/src/index.ts` at the top with other exports:

```typescript
// Export Supermemory functions (NEW - Epic 9)
export {addSupermemoryMemory, searchSupermemoryMemories} from "./supermemory";
```

### Step 4: Build and Test Locally (20 min)

```bash
cd functions

# Build TypeScript
npm run build

# Start Firebase Emulator
npm run serve

# Test functions with emulator (use Postman or iOS app)
```

### Step 5: Deploy to Production (10 min)

```bash
# Deploy ONLY the new functions
firebase deploy --only functions:addSupermemoryMemory,functions:searchSupermemoryMemories

# Or deploy all functions
firebase deploy --only functions

# Verify deployment
firebase functions:log
```

### Step 6: Verify Security (10 min)

- [x] API key already in Firebase secrets ‚úÖ
- [ ] Confirm API key NOT in new supermemory.ts code
- [ ] Test creator can call new functions
- [ ] Test non-creator gets permission denied
- [ ] Test unauthenticated requests fail
- [ ] Check Firebase Console for function logs

---

## üîó Related Files

- **New:** `functions/src/index.ts` - Cloud Functions implementation
- **New:** `functions/package.json` - Dependencies
- **New:** `functions/tsconfig.json` - TypeScript config
- **Modify:** `firebase.json` - Add functions configuration
- **Reference:** `.gitignore` - Ensure functions/node_modules ignored

---

## üìã Definition of Done

- [x] Firebase Functions already initialized ‚úÖ
- [x] `SUPERMEMORY_API_KEY` already configured as Firebase secret ‚úÖ
- [ ] `functions/src/supermemory.ts` created with both functions
- [ ] `addSupermemoryMemory` function implemented
- [ ] `searchSupermemoryMemories` function implemented
- [ ] Functions exported from `index.ts`
- [ ] Functions tested locally with emulator
- [ ] Functions deployed to `buzzbox-ios` Firebase project
- [ ] Security verified (API key not in client, only in Firebase)
- [ ] Creator-only access enforced server-side
- [ ] Error handling tested with various scenarios
- [ ] Cloud Logging verified working in Firebase Console
- [ ] Documentation complete

---

## ‚ö†Ô∏è Important Notes

1. **Security First:** API key NEVER in code, version control, or iOS app
2. **Creator Authorization:** Email check enforced server-side (not client)
3. **Graceful Degradation:** Search returns empty array on errors (don't break AI)
4. **Secrets Management:** SUPERMEMORY_API_KEY already configured ‚úÖ
5. **Testing:** Always test with emulator before production deployment
6. **Region:** Use `us-central1` (matches existing functions)
7. **Code Style:** Follow existing patterns from `faq.ts`, `ai-processing.ts`, etc.
8. **Logging:** Use `firebase-functions/logger` like existing functions
9. **Project:** Deploy to `buzzbox-ios` (not `buzzbox`)

---

## üîç Testing Guidance

### Local Testing with Emulator

```bash
# Terminal 1: Start emulator
cd /Users/andre/coding/buzzbox
firebase emulators:start

# Terminal 2: Test with curl (replace with actual Firebase auth token)
# Note: Use buzzbox-ios, not buzzbox
curl -X POST http://localhost:5001/buzzbox-ios/us-central1/addSupermemoryMemory \
  -H "Authorization: Bearer YOUR_FIREBASE_ID_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "data": {
      "content": "Q: Test question?\nA: Test answer!",
      "metadata": {"test": "true"}
    }
  }'
```

### Production Testing

1. Deploy functions: `firebase deploy --only functions`
2. Update iOS app to use production functions
3. Test as creator (Andrew's account)
4. Test as non-creator (should fail with permission-denied)
5. Check logs: `firebase functions:log`

---

## üéì Why This Architecture?

### Security Benefits

| Aspect | ‚ùå Client-Side API | ‚úÖ Cloud Functions |
|--------|--------------------|--------------------|
| API Key | In iOS app (extractable) | In Firebase (secure) |
| Access Control | Client-side (bypassable) | Server-side (enforced) |
| Rate Limiting | None | Firebase + Supermemory |
| Audit Logs | Limited | Full Cloud Logging |
| Secret Rotation | App update required | Update secret only |

### Cost Benefits

- **Prevents API abuse:** Server controls all Supermemory calls
- **Rate limiting:** Firebase enforces limits before hitting Supermemory
- **Monitoring:** Track usage in Cloud Logging/Monitoring

### Development Benefits

- **Easier testing:** Use Firebase Emulator locally
- **Better debugging:** Structured logs in Cloud Logging
- **No API key in iOS:** Simplifies iOS code, no Keychain needed

---

**Created by:** Product Owner (PO Agent)
**Date:** 2025-10-26
**Updated:** 2025-10-26 - Aligned with existing production setup
**Firebase Project:** buzzbox-ios
**Security Priority:** P0 - CRITICAL
**Blocks:** Stories 9.1, 9.2, 9.3, 9.4

---

## ‚úÖ Production Readiness Checklist

Before marking this story complete:

**Existing Setup Verified:**
- [x] Firebase project is `buzzbox-ios` ‚úÖ
- [x] Node 20 runtime configured ‚úÖ
- [x] TypeScript & Firebase Functions v2 ‚úÖ
- [x] SUPERMEMORY_API_KEY secret configured ‚úÖ
- [x] Existing functions deployed and working ‚úÖ

**New Implementation:**
- [ ] `supermemory.ts` created with proper structure
- [ ] Both callable functions implemented
- [ ] Exported from `index.ts`
- [ ] Built without errors (`npm run build`)
- [ ] Tested with emulator
- [ ] Deployed to production
- [ ] Verified in Firebase Console

**Security Verification:**
- [ ] API key NOT in supermemory.ts code
- [ ] API key accessed via `process.env.SUPERMEMORY_API_KEY`
- [ ] Creator email check enforced
- [ ] Functions require authentication
- [ ] Error messages don't leak sensitive info
