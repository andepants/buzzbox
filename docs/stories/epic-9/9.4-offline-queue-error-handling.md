# Story 9.4: Offline Queue & Robust Error Handling

**Epic:** Epic 9 - Supermemory RAG Integration
**Story ID:** 9.4
**Priority:** P2 (Medium)
**Estimated Time:** 2-3 hours
**Dependencies:** Story 9.1, 9.2, 9.3
**Status:** Draft

---

## üìñ User Story

**As** Andrew (the creator),
**I want** memory storage to work reliably even when offline or when API failures occur,
**So that** I don't lose valuable Q&A context due to network issues or temporary service outages.

---

## üéØ Acceptance Criteria

### Functional Requirements

1. **Offline Queue Implementation**
   - [ ] Create SwiftData model `PendingMemory` for offline queue
   - [ ] Store failed memory additions in local database
   - [ ] Auto-retry when network becomes available
   - [ ] Preserve Q&A content and metadata
   - [ ] FIFO queue processing (oldest first)

2. **Network Monitoring**
   - [ ] Detect network connectivity changes
   - [ ] Trigger queue processing when online
   - [ ] Use NWPathMonitor from Network framework
   - [ ] Run monitoring in background

3. **Retry Logic**
   - [ ] Exponential backoff for rate limiting (429 errors)
   - [ ] Max 3 retry attempts per memory
   - [ ] 5-second delay for first retry
   - [ ] 30-second delay for second retry
   - [ ] 2-minute delay for third retry
   - [ ] Discard after 3 failures (log only)

4. **Error Classification**
   - [ ] **Retryable:** Network errors (timeout, no connection)
   - [ ] **Retryable:** Server errors (500, 502, 503)
   - [ ] **Retryable:** Rate limiting (429)
   - [ ] **Non-Retryable:** Auth errors (401, 403)
   - [ ] **Non-Retryable:** Invalid request (400)
   - [ ] **Non-Retryable:** Not found (404)

### SwiftData Model Requirements

5. **PendingMemory Model**
   - [ ] Properties: `id`, `content`, `metadata`, `createdAt`, `retryCount`, `lastAttempt`
   - [ ] Conform to `@Model` macro
   - [ ] Stored in app's ModelContainer
   - [ ] Auto-deleted after successful sync

### Integration Requirements

6. **SupermemoryService Updates**
   - [ ] Modify `addMemory()` to use queue on failure
   - [ ] Add `processPendingMemories()` method
   - [ ] Add `clearPendingMemories()` for testing
   - [ ] Expose queue count via `@Published` property

7. **Background Processing**
   - [ ] Process queue on app foreground
   - [ ] Process queue when network detected
   - [ ] Batch process up to 5 memories at a time
   - [ ] Don't block app launch

### Code Quality Requirements

8. **Implementation Quality**
   - [ ] Add `// MARK: - Offline Queue` section
   - [ ] Extract retry logic into helper methods
   - [ ] Add comprehensive error logging
   - [ ] Keep SupermemoryService under 500 lines

9. **Testing**
   - [ ] Test offline ‚Üí send reply ‚Üí go online ‚Üí verify sync
   - [ ] Test rate limiting ‚Üí verify exponential backoff
   - [ ] Test invalid API key ‚Üí don't retry
   - [ ] Test queue with 10+ memories ‚Üí verify FIFO

---

## üîß Technical Implementation Notes

### SwiftData Model

**File:** `Core/Models/PendingMemory.swift`

```swift
import Foundation
import SwiftData

/// Represents a memory waiting to be synced to Supermemory
@Model
final class PendingMemory {
    @Attribute(.unique) var id: UUID
    var content: String
    var metadata: [String: String]
    var createdAt: Date
    var retryCount: Int
    var lastAttempt: Date?

    init(content: String, metadata: [String: String]) {
        self.id = UUID()
        self.content = content
        self.metadata = metadata
        self.createdAt = Date()
        self.retryCount = 0
        self.lastAttempt = nil
    }
}
```

### SupermemoryService Updates

**File:** `Core/Services/SupermemoryService.swift`

```swift
import Network
import SwiftData

// MARK: - Offline Queue

@Published private(set) var pendingMemoriesCount: Int = 0

private var pathMonitor: NWPathMonitor?
private var modelContext: ModelContext?

/// Initialize with ModelContext for offline queue
func configure(modelContext: ModelContext) {
    self.modelContext = modelContext
    startNetworkMonitoring()
    updatePendingCount()
}

/// Start monitoring network connectivity
private func startNetworkMonitoring() {
    pathMonitor = NWPathMonitor()
    pathMonitor?.pathUpdateHandler = { [weak self] path in
        if path.status == .satisfied {
            Task { @MainActor in
                await self?.processPendingMemories()
            }
        }
    }
    pathMonitor?.start(queue: DispatchQueue.global(qos: .background))
}

/// Enhanced addMemory with offline queue fallback
func addMemory(content: String, metadata: [String: String]? = nil) async throws {
    do {
        // Try direct API call first
        try await addMemoryToAPI(content: content, metadata: metadata)
    } catch {
        // If failed and retryable, queue for later
        if isRetryableError(error) {
            await queueMemory(content: content, metadata: metadata)
            print("üì• Queued memory for offline sync")
        } else {
            print("‚ùå Non-retryable error: \(error)")
            throw error
        }
    }
}

/// Queue memory for later sync
private func queueMemory(content: String, metadata: [String: String]?) async {
    guard let modelContext = modelContext else { return }

    await MainActor.run {
        let pending = PendingMemory(
            content: content,
            metadata: metadata ?? [:]
        )
        modelContext.insert(pending)
        try? modelContext.save()
        updatePendingCount()
    }
}

/// Process all pending memories
func processPendingMemories() async {
    guard let modelContext = modelContext else { return }

    let descriptor = FetchDescriptor<PendingMemory>(
        sortBy: [SortDescriptor(\.createdAt)]
    )

    guard let pending = try? modelContext.fetch(descriptor) else { return }

    print("üîÑ Processing \(pending.count) pending memories")

    for memory in pending.prefix(5) { // Batch of 5
        do {
            // Calculate backoff delay
            if let lastAttempt = memory.lastAttempt {
                let delay = backoffDelay(for: memory.retryCount)
                let timeSinceLastAttempt = Date().timeIntervalSince(lastAttempt)
                if timeSinceLastAttempt < delay {
                    continue // Skip, too soon
                }
            }

            // Attempt sync
            try await addMemoryToAPI(
                content: memory.content,
                metadata: memory.metadata
            )

            // Success: Remove from queue
            await MainActor.run {
                modelContext.delete(memory)
                try? modelContext.save()
            }
            print("‚úÖ Synced pending memory")

        } catch {
            // Update retry count
            await MainActor.run {
                memory.retryCount += 1
                memory.lastAttempt = Date()

                // Discard after 3 attempts
                if memory.retryCount >= 3 {
                    print("‚ùå Discarding memory after 3 attempts")
                    modelContext.delete(memory)
                }

                try? modelContext.save()
            }
        }
    }

    await MainActor.run {
        updatePendingCount()
    }
}

/// Calculate exponential backoff delay
private func backoffDelay(for retryCount: Int) -> TimeInterval {
    switch retryCount {
    case 0: return 5      // 5 seconds
    case 1: return 30     // 30 seconds
    case 2: return 120    // 2 minutes
    default: return 300   // 5 minutes
    }
}

/// Determine if error is retryable
private func isRetryableError(_ error: Error) -> Bool {
    if let supermemoryError = error as? SupermemoryError {
        switch supermemoryError {
        case .notConfigured, .decodingError:
            return false
        case .invalidResponse(let code):
            return code >= 500 || code == 429 // Server errors or rate limit
        case .networkError, .timeout:
            return true
        }
    }
    return true // Default to retryable
}

/// Update published pending count
private func updatePendingCount() {
    guard let modelContext = modelContext else { return }
    let descriptor = FetchDescriptor<PendingMemory>()
    pendingMemoriesCount = (try? modelContext.fetchCount(descriptor)) ?? 0
}
```

### App Initialization

**File:** `buzzboxApp.swift`

```swift
.onAppear {
    // Configure SupermemoryService with ModelContext
    SupermemoryService.shared.configure(
        modelContext: modelContext
    )
}

.onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
    // Process pending memories on app foreground
    Task {
        await SupermemoryService.shared.processPendingMemories()
    }
}
```

---

## üîó Related Files

- **New:** `Core/Models/PendingMemory.swift` - SwiftData model for queue
- **Modify:** `Core/Services/SupermemoryService.swift` - Add queue logic
- **Modify:** `buzzboxApp.swift` - Configure service on launch
- **Reference:** Existing SwiftData patterns in `Core/Models/`

---

## üìã Definition of Done

- [ ] `PendingMemory` SwiftData model created
- [ ] `SupermemoryService` updated with queue logic
- [ ] Network monitoring implemented
- [ ] Exponential backoff retry logic working
- [ ] Error classification implemented
- [ ] All acceptance criteria met and tested
- [ ] Code compiles without warnings
- [ ] Manual testing completed successfully
- [ ] Queue processes correctly on network restore
- [ ] No memory leaks from NWPathMonitor

---

## ‚ö†Ô∏è Important Notes

1. **Data Persistence:** Queue survives app restarts (SwiftData)
2. **Battery Efficiency:** Don't spam retries (exponential backoff)
3. **Memory Limits:** Discard after 3 failures to prevent infinite growth
4. **Non-Retryable:** Auth errors mean API key is wrong (user must fix)
5. **Privacy:** Queue stored locally, never sent elsewhere

---

## üîç Testing Guidance

### Manual Testing Steps

**Test 1: Offline Queue**
1. Enable airplane mode
2. Login as Andrew
3. Send 3 replies to fans
4. ‚úÖ Verify console: "üì• Queued memory for offline sync" (3x)
5. Disable airplane mode
6. ‚úÖ Verify console: "üîÑ Processing 3 pending memories"
7. ‚úÖ Verify console: "‚úÖ Synced pending memory" (3x)

**Test 2: Exponential Backoff**
1. Set invalid API key (to trigger failures)
2. Send reply
3. ‚úÖ First retry after 5 seconds
4. ‚úÖ Second retry after 30 seconds
5. ‚úÖ Third retry after 2 minutes
6. ‚úÖ Memory discarded after 3rd failure

**Test 3: Non-Retryable Error**
1. Set completely invalid API key
2. Send reply
3. ‚úÖ Verify console: "‚ùå Non-retryable error"
4. ‚úÖ Memory NOT queued (immediate failure)

**Test 4: Network Change Detection**
1. Start app with Wi-Fi
2. Queue 5 memories (disable Supermemory temporarily)
3. Enable Supermemory
4. Toggle airplane mode OFF
5. ‚úÖ Processing starts automatically

**Test 5: App Restart Persistence**
1. Queue 3 memories
2. Force quit app
3. Restart app
4. Go online
5. ‚úÖ Queued memories still present and sync

---

## üéì Technical Deep Dive

### Why Offline Queue Matters

**Problem Without Queue:**
- Andrew sends reply on subway (offline)
- Memory storage fails silently
- AI never learns from that conversation
- Inconsistent knowledge base

**Solution With Queue:**
- Reply stored locally
- Syncs when network available
- No manual intervention needed
- Complete knowledge base

### Exponential Backoff Explained

**Why Not Constant Retry?**
- Constant retry = battery drain + API spam
- Server might be down (retrying won't help immediately)
- Rate limiting needs time to reset

**Exponential Strategy:**
- First retry: 5 seconds (quick transient error)
- Second retry: 30 seconds (longer outage)
- Third retry: 2 minutes (serious issue)
- After 3: Give up (avoid infinite loop)

**Real-World Benefit:**
- Handles 99% of network blips
- Respects API rate limits
- Battery efficient
- Self-healing system

---

**Created by:** Sarah (PO Agent)
**Date:** 2025-10-26
**Depends on:** Stories 9.1, 9.2, 9.3 completed
