# Story 9.2: Memory Storage on Manual Replies

**Epic:** Epic 9 - Supermemory RAG Integration
**Story ID:** 9.2
**Priority:** P1 (High)
**Estimated Time:** 2-3 hours
**Dependencies:** Story 9.0 (Firebase Functions), Story 9.1 (Supermemory Service)
**Status:** Draft

> **Note:** SupermemoryService uses Firebase Cloud Functions to securely store memories.
> The API key is stored in Firebase, never in the iOS app.

---

## 📖 User Story

**As** Andrew (the creator),
**I want** my manual replies to automatically be stored as Q&A pairs in Supermemory,
**So that** the AI can learn from my actual responses and improve over time without manual FAQ management.

---

## 🎯 Acceptance Criteria

### Functional Requirements

1. **Trigger Detection**
   - [ ] Hook into `MessageThreadViewModel.sendMessage()` method
   - [ ] Detect when sender is the creator (`AuthService.shared.isCreator == true`)
   - [ ] Only trigger storage for manual replies (not AI-generated drafts)
   - [ ] Fire-and-forget pattern (don't block message sending)

2. **Context Extraction**
   - [ ] Extract the last fan message from conversation history
   - [ ] Extract Andrew's reply text (current message being sent)
   - [ ] Skip memory storage if no fan context exists
   - [ ] Handle conversations with multiple rapid fan messages (use most recent)

3. **Q&A Pair Formatting**
   - [ ] Format as: `"Q: {fan message}\nA: {andrew reply}"`
   - [ ] Preserve emoji and formatting in both question and answer
   - [ ] Truncate extremely long messages (>2000 chars) with ellipsis
   - [ ] Strip leading/trailing whitespace

4. **Metadata Enrichment**
   - [ ] Include `conversationID` from current conversation
   - [ ] Include ISO8601 timestamp of reply
   - [ ] Include `category` from `conversation.aiCategory` (if available)
   - [ ] Include `platform: "ios"` tag
   - [ ] Include `creator: "andrew"` tag

5. **Supermemory Integration**
   - [ ] Call `SupermemoryService.shared.addMemory()` asynchronously
   - [ ] Service internally calls Firebase Cloud Function (secure)
   - [ ] Use `Task.detached` to prevent blocking
   - [ ] Pass formatted Q&A content and metadata
   - [ ] Don't await result (fire-and-forget)

### Error Handling Requirements

6. **Graceful Degradation**
   - [ ] Message sending succeeds even if memory storage fails
   - [ ] Log errors to console without showing user alerts
   - [ ] Track failure count for debugging (optional)

7. **Edge Case Handling**
   - [ ] Skip if `SupermemoryService.shared.isEnabled == false`
   - [ ] Skip if fan message is empty or only whitespace
   - [ ] Skip if Andrew's reply is empty
   - [ ] Skip for system messages or announcements

### Code Quality Requirements

8. **Implementation Quality**
   - [ ] Add `// MARK: - Supermemory Integration` section
   - [ ] Extract memory logic into private helper method
   - [ ] Add doc comments explaining the Q&A learning pattern
   - [ ] Keep `sendMessage()` method readable (delegate to helper)

9. **Testing**
   - [ ] Manual test: Send message as creator → verify API call in logs
   - [ ] Manual test: Send message as fan → verify no API call
   - [ ] Manual test: Disable Supermemory → verify no crash
   - [ ] Manual test: Offline mode → verify message still sends

---

## 🔧 Technical Implementation Notes

### Integration Point

**File:** `Core/ViewModels/MessageThreadViewModel.swift`

**Method:** `sendMessage()` - Add hook after message is saved to Firebase but before UI updates

### Code Implementation Pattern

```swift
// MARK: - Supermemory Integration

/// Stores Andrew's manual reply as a Q&A pair in Supermemory
/// Fire-and-forget pattern: doesn't block message sending
private func storeReplyInSupermemory(fanMessage: Message, andrewReply: String, conversationID: String, category: String?) {
    // Only for creator replies
    guard AuthService.shared.isCreator else { return }

    // Only if Supermemory is enabled
    guard SupermemoryService.shared.isEnabled else { return }

    // Validate inputs
    guard !fanMessage.text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty,
          !andrewReply.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
        return
    }

    // Format Q&A pair
    let qaPair = """
    Q: \(fanMessage.text)
    A: \(andrewReply)
    """

    // Build metadata
    let metadata: [String: String] = [
        "conversationID": conversationID,
        "timestamp": ISO8601DateFormatter().string(from: Date()),
        "category": category ?? "unknown",
        "platform": "ios",
        "creator": "andrew"
    ]

    // Store in background (fire-and-forget)
    Task.detached(priority: .background) {
        do {
            try await SupermemoryService.shared.addMemory(
                content: qaPair,
                metadata: metadata
            )
            print("✅ Stored reply in Supermemory")
        } catch {
            print("⚠️ Failed to store reply in Supermemory: \(error)")
            // Don't propagate error - graceful degradation
        }
    }
}
```

### Integration in sendMessage()

```swift
func sendMessage(text: String) async {
    // ... existing message sending logic ...

    // Store Q&A pair in Supermemory (fire-and-forget)
    if let lastFanMessage = getLastFanMessage() {
        storeReplyInSupermemory(
            fanMessage: lastFanMessage,
            andrewReply: text,
            conversationID: conversation.id,
            category: conversation.aiCategory
        )
    }

    // ... rest of existing logic ...
}
```

### Helper Method for Context Extraction

```swift
/// Gets the most recent message from a fan (non-creator)
private func getLastFanMessage() -> Message? {
    return messages
        .filter { $0.senderID != AuthService.shared.currentUser?.uid }
        .sorted { $0.timestamp > $1.timestamp }
        .first
}
```

---

## 🔗 Related Files

- **Modify:** `Core/ViewModels/MessageThreadViewModel.swift` - Add Supermemory hook
- **Reference:** `Core/Services/SupermemoryService.swift` - Call addMemory() (uses Cloud Functions)
- **Reference:** `Core/Services/AuthService.swift` - Check if creator
- **Reference:** `Core/Models/Message.swift` - Message structure
- **Dependency:** Firebase Cloud Functions (Story 9.0) - Stores API key securely

---

## 📋 Definition of Done

- [ ] `MessageThreadViewModel.sendMessage()` includes Supermemory integration
- [ ] Helper method `storeReplyInSupermemory()` implemented
- [ ] Helper method `getLastFanMessage()` implemented
- [ ] All acceptance criteria met and tested
- [ ] Code compiles without warnings
- [ ] Fire-and-forget pattern implemented (non-blocking)
- [ ] Graceful degradation if Supermemory disabled or fails
- [ ] Error logging added (no user-facing alerts)
- [ ] Manual testing completed successfully
- [ ] Code reviewed for edge cases

---

## ⚠️ Important Notes

1. **Non-Blocking Critical:** Message sending MUST succeed even if Supermemory fails
2. **Privacy:** Only store 1:1 DM conversations (not group channels) - Add check if needed
3. **Fire-and-Forget:** Use `Task.detached` with `.background` priority
4. **No User Alerts:** Never show errors to user for background memory storage
5. **Context Required:** Skip if no fan message exists (can't create Q&A without question)
6. **Security:** API calls go through Firebase Cloud Functions (API key secure on server)

---

## 🔍 Testing Guidance

### Manual Testing Steps

**Test 1: Happy Path**
1. Login as Andrew (creator account)
2. Open DM conversation with a fan
3. Fan sends: "When is your next stream?"
4. Andrew replies: "Saturday at 3pm EST!"
5. ✅ Verify console log: "✅ Memory stored via Cloud Function"
6. Check Firebase Functions logs (not direct Supermemory API)

**Test 2: Fan Account**
1. Login as fan (non-creator)
2. Send message to Andrew
3. ✅ Verify NO API call made

**Test 3: Supermemory Disabled**
1. Remove API key from Keychain
2. Login as Andrew
3. Send reply to fan
4. ✅ Message sends successfully
5. ✅ No crash or error shown

**Test 4: Network Failure**
1. Enable airplane mode
2. Login as Andrew
3. Send reply to fan
4. ✅ Message queues for Firebase sync
5. ✅ Console shows: "⚠️ Failed to store reply in Supermemory"
6. ✅ No crash

**Test 5: Edge Cases**
- Empty fan message → Skip storage
- Whitespace-only reply → Skip storage
- Very long message (>5000 chars) → Truncate gracefully
- Multiple fan messages in a row → Use most recent

---

## 🎓 Learning Context

This story implements the "write" side of the RAG pattern:
- **Story 9.2 (this):** Write → Store Q&A pairs
- **Story 9.3 (next):** Read → Search and retrieve for AI context

The memory storage is **automatic and invisible** to Andrew - it just happens in the background every time he sends a reply. Over time, this builds a comprehensive knowledge base of how Andrew actually communicates with fans.

---

**Created by:** Sarah (PO Agent)
**Date:** 2025-10-26
**Updated:** 2025-10-26 - Uses Firebase Cloud Functions (secure)
**Depends on:** Stories 9.0 and 9.1 must be completed first
