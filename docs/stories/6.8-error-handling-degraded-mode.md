# Story 6.8: Error Handling & Degraded Mode

## Status
Draft

## Story
**As a** user,
**I want** messages to work even when AI features fail,
**so that** the core messaging experience is reliable regardless of AI service status.

## Acceptance Criteria
1. Messages send/receive even if Cloud Functions are down
2. Auto-processing has 5s timeout
3. Failed AI processing doesn't retry indefinitely
4. FAQ check failures return `isFAQ: false` (silent fail)
5. Smart reply failures show user-friendly error
6. Error logs in Firebase Console for debugging
7. Degraded mode clearly visible (no AI badges)

## Tasks / Subtasks

- [ ] Add timeout to auto-processing Cloud Function (AC: 2)
  - [ ] Open `functions/src/ai-processing.ts`
  - [ ] Wrap AI processing in Promise.race with timeout
  - [ ] Create typed timeout promise: `new Promise<never>((_, reject) => setTimeout(() => reject(new Error('AI processing timeout')), 5000))`
  - [ ] Race between AI processing and timeout
  - [ ] Timeout set to 5 seconds (5000ms)
  - [ ] Fix typing: `const [category, sentiment, score] = await Promise.race([processing, timeout]);`

- [ ] Add retry logic with exponential backoff (AC: 3)
  - [ ] In `processMessageAI`, track retry attempts
  - [ ] Add field to message: `aiProcessingAttempts: number`
  - [ ] Distinguish transient errors (network, timeout) from permanent errors (invalid data)
  - [ ] Allow up to 3 retries for transient errors only
  - [ ] Use exponential backoff: wait 1s, 2s, 4s between retries
  - [ ] Mark as `aiProcessingFailed: true` only after 3 failed attempts
  - [ ] Skip processing if `aiProcessingFailed: true` already set

- [ ] Prevent infinite retries for permanent failures (AC: 3)
  - [ ] In `processMessageAI` function, check if message has `aiProcessingFailed: true`
  - [ ] Skip processing if already marked as permanently failed
  - [ ] On permanent error (after retries exhausted), update with `aiProcessingFailed: true`
  - [ ] Also set `aiProcessedAt: ServerValue.TIMESTAMP` to mark as "attempted"

- [ ] Add graceful error handling in auto-processing (AC: 1)
  - [ ] Wrap entire function in try/catch
  - [ ] On error: log with `logger.error()` including error details
  - [ ] On error: update message with failure flag
  - [ ] Return `{ success: false, error: String(error) }` (don't throw)
  - [ ] Never fail the message write operation

- [ ] Update FAQ check to fail silently with logging (AC: 4)
  - [ ] Open `buzzbox/Core/Services/AIService.swift`
  - [ ] Find `checkFAQ(_ text: String)` method
  - [ ] Wrap in do-catch block
  - [ ] On error: log with structured logging
  - [ ] Log format: `console.error('FAQ check failed', { error, messageText: text.substring(0, 50) })`
  - [ ] On error: return `FAQResponse(isFAQ: false, answer: nil, matchedQuestion: nil)`
  - [ ] Never throw errors from checkFAQ (always return a response)
  - [ ] Consider adding Firebase Analytics event for AI failures (optional)

- [ ] Add user-friendly error handling for smart replies (AC: 5)
  - [ ] In `generateSmartReplies` method, errors should still throw (user-initiated action)
  - [ ] Open `buzzbox/Features/Messages/Views/MessageThreadView.swift`
  - [ ] Find smart reply button Task
  - [ ] Add state variables: `@State private var errorMessage = ""`, `@State private var showError = false`
  - [ ] In catch block: set `errorMessage = "Failed to generate AI replies. Please try again."`
  - [ ] In catch block: set `showError = true`
  - [ ] Add `.alert("Error", isPresented: $showError)` modifier with error message

- [ ] Enhance Cloud Functions error logging (AC: 6)
  - [ ] In all Cloud Functions (ai-processing.ts, faq.ts, smart-replies.ts):
  - [ ] Use `logger.error()` with context object: `{ error, messageId, conversationId }`
  - [ ] Use `logger.info()` for successful operations
  - [ ] Include performance metrics: `{ duration: endTime - startTime }`
  - [ ] Errors will appear in Firebase Console > Functions > Logs

- [ ] Test degraded mode visibility (AC: 7)
  - [ ] Send message when Cloud Functions are working
  - [ ] Verify AI badges appear
  - [ ] Simulate Cloud Function failure using one of these methods:
    - Option 1: Comment out function export in `functions/src/index.ts`
    - Option 2: Deploy function with intentional `throw new Error()` at start
    - Option 3: Temporarily modify Firebase Security Rules to block function
    - Option 4: Use Firebase Emulator with function disabled
  - [ ] Document which method was used for testing
  - [ ] Send message during simulated failure
  - [ ] Verify message sends successfully (core feature works)
  - [ ] Verify NO AI badges appear (degraded mode)
  - [ ] Verify message still displays normally
  - [ ] Rollback simulation changes after testing

- [ ] Test timeout scenario
  - [ ] Modify Cloud Function to add artificial delay (10s sleep)
  - [ ] Send message and verify timeout triggers at 5s
  - [ ] Verify message is marked as `aiProcessingFailed: true`
  - [ ] Verify subsequent messages don't retry failed processing
  - [ ] Remove artificial delay after testing

- [ ] Test error recovery
  - [ ] Disable Cloud Functions
  - [ ] Send multiple messages (verify they work)
  - [ ] Re-enable Cloud Functions
  - [ ] Send new message
  - [ ] Verify AI processing resumes for new messages
  - [ ] Verify old messages remain without AI metadata

- [ ] (Optional) Add manual retry capability
  - [ ] Add button in Settings: "Retry AI Processing for Recent Messages"
  - [ ] Query messages with `aiProcessingFailed: true` from last 24 hours
  - [ ] Reset `aiProcessingFailed` flag to allow retry
  - [ ] Limit to 10 most recent failed messages
  - [ ] Show success/failure count after retry
  - [ ] This is optional enhancement - not required for AC

## Dev Notes

### Architecture Context

**Service Layer Error Handling** [Source: architecture/application-layers.md#5.1]
- Service Layer handles errors, retries, rate limiting
- Services throw errors to ViewModels
- ViewModels catch errors and display to users

**Offline-First Strategy** [Source: architecture/offline-first-strategy.md - assumed]
- Core messaging must work offline and when backend fails
- AI features are enhancements, not requirements
- Graceful degradation is critical for UX

### Error Handling Strategy

**Cloud Functions (Backend):**
- Auto-processing: Silent failure (log error, mark as failed, continue)
- FAQ check: Silent failure (return isFAQ: false)
- Smart replies: Throw error (user-initiated, show error to user)

**iOS (Frontend):**
- Auto-processing: No code needed (happens automatically)
- FAQ check: Silent failure (return isFAQ: false, no error shown)
- Smart replies: Show user-friendly error alert

**Why This Strategy:**
- Auto-processing is background automation → user doesn't know it's happening
- FAQ check is automatic → user doesn't know it's happening
- Smart replies are user-initiated → user expects feedback on failure

### File Locations

**Files to Modify (Cloud Functions):**
- `functions/src/ai-processing.ts` - Add timeout and error handling
- (faq.ts and smart-replies.ts already have error handling from Stories 6.3 and 6.4)

**Files to Modify (iOS):**
- `buzzbox/Core/Services/AIService.swift` - Silent failure for checkFAQ
- `buzzbox/Features/Messages/Views/MessageThreadView.swift` - Error alert for smart replies

### Implementation Details

**Auto-Processing with Timeout (ai-processing.ts):**
```typescript
export const processMessageAI = onValueWritten({
  ref: '/messages/{conversationId}/{messageId}',
  region: 'us-central1',
}, async (event) => {
  const change = event.data;

  if (!change.after.exists()) {
    return null;
  }

  const message = change.after.val() as Message;

  // Only process messages sent to creator
  const CREATOR_UID = 'UoLk9GtxDaaYGlI8Ah6RnCbXXbf2';
  if (message.receiverId !== CREATOR_UID) {
    return null;
  }

  // Skip if already processed or failed
  if (change.after.child('aiCategory').exists() || change.after.child('aiProcessingFailed').exists()) {
    return null;
  }

  try {
    // Timeout after 5 seconds
    const timeout = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('AI processing timeout')), 5000)
    );

    const processing = Promise.all([
      categorizeMessage(message.text),
      analyzeSentiment(message.text),
      scoreOpportunity(message.text),
    ]);

    const [category, sentiment, score] = await Promise.race([
      processing,
      timeout,
    ]) as [string, string, number | null];

    // Update with AI metadata
    await change.after.ref.update({
      aiCategory: category,
      aiSentiment: sentiment,
      aiOpportunityScore: score,
      aiProcessedAt: admin.database.ServerValue.TIMESTAMP,
    });

    logger.info('AI processing successful', {
      messageId: message.id,
      category,
      sentiment,
      score,
    });

    return { success: true };

  } catch (error) {
    // Log error but don't fail
    logger.error('AI processing failed', {
      error,
      messageId: message.id,
      conversationId: event.params.conversationId,
    });

    // Mark as failed so we don't retry
    await change.after.ref.update({
      aiProcessingFailed: true,
      aiProcessedAt: admin.database.ServerValue.TIMESTAMP,
    });

    return { success: false, error: String(error) };
  }
});
```

**Silent Failure for checkFAQ (AIService.swift):**
```swift
func checkFAQ(_ text: String) async throws -> FAQResponse {
    do {
        let result = try await functions.httpsCallable("checkFAQ")
            .call(["text": text])

        let data = try JSONSerialization.data(withJSONObject: result.data)
        return try JSONDecoder().decode(FAQResponse.self, from: data)
    } catch {
        // Log error but don't throw - return non-FAQ response
        print("FAQ check failed: \(error)")
        return FAQResponse(isFAQ: false, answer: nil, matchedQuestion: nil)
    }
}
```

**User-Friendly Error for Smart Replies (MessageThreadView.swift):**
```swift
@State private var errorMessage = ""
@State private var showError = false

Button {
    Task {
        isLoadingDrafts = true
        do {
            smartReplyDrafts = try await aiService.generateSmartReplies(
                conversationId: viewModel.conversationId,
                messageText: viewModel.lastMessage?.text ?? ""
            )
            showSmartReplies = true
        } catch {
            // Show error toast
            errorMessage = "Failed to generate AI replies. Please try again."
            showError = true
        }
        isLoadingDrafts = false
    }
} label: {
    if isLoadingDrafts {
        ProgressView()
    } else {
        Label("Draft Reply", systemImage: "sparkles")
    }
}
.disabled(isLoadingDrafts)
.alert("Error", isPresented: $showError) {
    Button("OK", role: .cancel) { }
} message: {
    Text(errorMessage)
}
```

### Testing

**Testing Approach:**
1. Test normal operation (all AI features working)
2. Test timeout scenario (artificial 10s delay)
3. Test Cloud Functions completely disabled
4. Test network errors (airplane mode)
5. Test recovery (re-enable after failure)

**Test Cases:**
- Normal operation: Verify all AI features work
- Timeout: Verify 5s timeout triggers, message marked as failed
- Cloud Functions disabled: Verify messages still send/receive
- FAQ failure: Verify messages work, no auto-response
- Smart reply failure: Verify error alert shown, message composer still works
- Recovery: Verify AI features resume after failure is fixed

**Expected Behaviors:**
- Messages ALWAYS send/receive (core feature)
- AI badges appear when processing succeeds
- No AI badges appear when processing fails (degraded mode)
- No user-visible errors for background AI failures
- User-friendly error for user-initiated AI failures (smart replies)

**Testing Standards** [Source: architecture/testing-strategy.md - assumed]
- Manual testing in various failure scenarios
- Verify graceful degradation
- Verify error logs in Firebase Console
- Verify user experience remains smooth

### Important Notes

- Core messaging MUST NEVER FAIL due to AI features
- AI features are enhancements, not requirements
- Graceful degradation ensures good UX during outages
- Error logs help debug issues in production
- Timeout prevents slow AI calls from blocking forever
- Failed processing is marked to prevent infinite retries

### Prerequisites

- Stories 6.2, 6.3, 6.4 (Cloud Functions) must be deployed
- Story 6.5 (AIService) must be complete
- Story 6.7 (AI UI Components) must be complete
- App must handle AI metadata being optional/nil

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-22 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

*This section will be populated by the development agent during implementation.*

### Agent Model Used

*To be populated by dev agent*

### Debug Log References

*To be populated by dev agent*

### Completion Notes

*To be populated by dev agent*

### File List

*To be populated by dev agent*

## QA Results

*This section will be populated by the QA agent after story completion.*
